教程简介：在本教程中我们将要介绍OGRE最基本的一些对象的构建，它包括：场景管理器（SceneManager），场景节点（SceneNode）和实体（Entity ）对象。我们的内容不会包含很多的代码；相反的我们将注意力集中在你开始学习OGRE的一般的概念上。
  在你学习本教程的过程中你应该慢慢的向你的项目中添加代码并且观察加入的代码产生的结果。除了自己动手写代码，没有其他的方法可以让你熟悉这些概念。忍住冲动，耐心的读完吧。  

如果你在学习本教程的过程中遇到了任何问题，你应该将这个问题发布在帮助论坛（http://www.ogre3d.org/forums/viewforum.php?f=2）上。

前提条件---------------------------------------------------------------------------------------------------------------------
  本教程认为你已经知道如何使用C++语言编程并且能够设置和编译Ogre程序。
  本教程同样认为你已经使用Ogre Wiki Tutorial Framework、CMake或者Ogre Appwizard创建了一个工程。如果没有的话请看http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Setting+Up+An+Application吧。

目录—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
-----------------------------------------------------------------------------------------------------------------------------
--前提条件
--开始
----初始代码
----疑难排除
------MessageBox函数问题
------缺少配置文件或DLL
------资源或插件问题
------在Visual Studio或Code::Blocks中不能启动程序
--Ogre如何工作
----场景管理器
----实体
----场景节点
--你的第一个Ogre程序
--坐标系与向量
--添加另外一个对象
--实体更多介绍
--场景更多介绍
--应该尝试去做的
----缩放
----旋转
--Ogre环境
----DLL和插件
------Main库
------插件
------第三方库和辅助库
------测试与发布
--------例子
----配置文件
--总结
-----------------------------------------------------------------------------------------------------------------------------
—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

开始
—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
初始代码
-----------------------------------------------------------------------------------------------------------------------------
    在本教程中我们将使用之前写好的代码。除了我们将要加入createScene 函数的代码外你应该忽视所有其他的代码。我们将在后面的教程中进一步解释Ogre程序是如何运行的，但是现在我们将从最基本的部分开始。
    请阅读"setting up an application"(http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Setting+Up+An+Application)去学习如何使用你的IDE和环境创建一个初始的项目。
    创建名称为Tutorial的项目
    将教程程序框架添加到你的项目中：
    ---------------------------------
    --  BaseApplication.h          --
	--  BaseApplication.cpp        --
	--  TutorialApplication.h      --
	--  TutorialApplication.cpp    --
	---------------------------------
	你可以从Ogre Wiki Tutorial Framework(http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Ogre+Wiki+Tutorial+Framework)得到这些文件，或者使用 Ogre AppWizard(https://bitbucket.org/jacmoe/ogreappwizards/downloads)。
	TutorialApplication.cpp是我们教程将要使用的唯一一个文件，并且我们只会修改其中的createScene()成员函数。
	TutorialApplication.cpp应该包含如下的代码（为了保持整洁，移除了头文件注释）。
	---------------------------------------------------------------------------------------------------------------------
	#include "TutorialApplication.h"
 
	TutorialApplication::TutorialApplication(void)
	{
	}
 
	TutorialApplication::~TutorialApplication(void)
	{
	}
 
	//-------------------------------------------------------------------------------------
	void TutorialApplication::createScene(void)
	{
    	// Set the scene's ambient light
    	mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5f, 0.5f, 0.5f));
 
    	// Create an Entity
	 	Ogre::Entity* ogreHead = mSceneMgr->createEntity("Head", "ogrehead.mesh");
 
    	// Create a SceneNode and attach the Entity to it
    	Ogre::SceneNode* headNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("HeadNode");
    	headNode->attachObject(ogreHead);
 
    	// Create a Light and set its position
    	Ogre::Light* light = mSceneMgr->createLight("MainLight");
    	light->setPosition(20.0f, 80.0f, 50.0f);
	}
 
 
 
	#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
	#define WIN32_LEAN_AND_MEAN
	#include "windows.h"
	#endif
 
	#ifdef __cplusplus
	extern "C" {
	#endif
 
	#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 		INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
	#else
    	int main(int argc, char *argv[])
	#endif
    	{
        	// Create application object
        	TutorialApplication app;
 
        	try 
        	{
        	 	app.go();
        	} catch( Ogre::Exception& e ) {
	#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            	MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR| MB_TASKMODAL);
	#else
            	std::cerr << "An exception has occured: " << e.getFullDescription().c_str() << std::endl;
	#endif
        	}
 
        	return 0;
    	}
 
	#ifdef __cplusplus
	}
	#endif
-----------------------------------------------------------------------------------------------------------------------------
	编译并运行你的程序，以保证你的环境配置是正确的。如果你的程序运行了，使用WASD健移动物体、使用鼠标看看周围。按下Esc健退出程序。
-----------------------------------------------------------------------------------------------------------------------------
	
	疑难排除
	---------------------------------------------------------------------------------------------------------------------
	如果你遇到了问题，检查Setting Up An Application(http://www.ogre3d.org/tikiwiki/tiki-index.php?page=Setting+Up+An+Application)你的编译器是否正确的设置了，后者查看Ogre.log获取更多的详细信息。如果你需要进一步的帮助，在论坛上搜索(http://www.ogre3d.org/forums/search.php)，也许你的问题别人已经遇到过很多次了。如果这是一个新的问题，请阅读论坛规则（http://www.ogre3d.org/forums/viewtopic.php?t=11886），然后提问（http://www.ogre3d.org/forums/viewforum.php?f=2）。请确保从你的Ogre.log、异常、错误信息或者调试后的痕迹（debugger back traces）。
	注意：以后的教程将不会包含疑难排除信息，如果你遇到了问题那么请特别注意下面的部分。
	MessageBox问题----------------------------------------------------------------------------------------------------------
	如果你使用的Visual Studio并且本项目打开了Unicode支持，那么你可能会遇到下面的错误：
	------------------------------------------------------------------------------------------------------------------------
	-- error C2664: 'MessageBoxW' : cannot convert parameter 2 from 'const char *' to 'LPCWSTR'
    --      Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or  function-style cast
    -------------------------------------------------------------------------------------------------------------------------
    产生这个问题的原因是MessageBox函数（在这个情况下）需要Unicode编码，但是我们却给它一个ANSI字符串。为了解决这个问题，将下面这一行：
    MessageBox( NULL, e.what(), "An exception has occurred!", MB_OK |   MB_IConerror  | MB_TASKMODAL);
    改为：
    MessageBoxA( NULL, e.what(), "An exception has occurred!", MB_OK |   MB_IConerror  | MB_TASKMODAL);
    或者你可以在编译器中将你的文本格式从Unicode改为ANSI。这样的话你将失去国际语言的支持。
    这样做的理由是：MessageBox将会根据项目的配置自动的解析为MessageBoxA (ANSI)或者MessageBoxW (Wide/Unicode)。我们通过显式的指定它使用ANSI来解决这个问题。
    -------------------------------------------------------------------------------------------------------------------------
    
    丢失配置文件或者DLL
    -------------------------------------------------------------------------------------------------------------------------
    	如果你试着启动刚创建的程序但是程序却抱怨（提示）丢失DLL或配置文件（*.cfg），那么你很有可能没有从OgreSDK文件夹中将它们复制过来。在Visual Studio中，当你在release模式下编译你的程序，它把release的可执行文件放在了[ProjectFolder]\bin\release文件夹中，debug的可执行文件放在了[ProjectFolder]\bin\debug 文件夹中。你必须从OgreSDK文件夹中复制所有的".dll"和".cfg"文件到正确的文件夹中。也就是从[OgreSDK]\bin\release复制到[ProjectFolder]\bin\release、[OgreSDK]\bin\debug到[ProjectFolder]\bin\debug。你同样需要编辑resources.cfg文件以指出正确的路径。下一小节将会更加详细的介绍。
    -------------------------------------------------------------------------------------------------------------------------
    
    资源或插件问题
    -------------------------------------------------------------------------------------------------------------------------
    	确保在一个相同的包含可执行文件的文件夹下有plugins.cfg和resources.cfg文件。plugins.cfg告诉OGRE有哪些渲染库是可用的（Direct3D9，OpenGL,etc）。resources.cfg是给ExampleApplication使用的，它指出了纹理、网格模型和脚本的路径。它们都是文本文件（指配置文件），所以编辑它们以保证路径是正确的。否则你的OGRE可能没有任何渲染库，或者你的屏幕或者Ogre.log将显示类似下面的错误：
    	Description: ../../Media/packs/OgreCore.zip - error whilst opening archive: Unable to read zip file
    	如果是这样的话，打开resources.cfg文件，改变它包含的位置使它指向Media文件夹中包含该资源的位置。注意：在这些路径中你不能使用诸如$(SomeVariable)之类的环境变量。
   	---------------------------------------------------------------------------------------------------------------------
   	
   	在Visual Studio或者Code::Blocks不能启动程序
   	---------------------------------------------------------------------------------------------------------------------
   	如果你使用Visual Studio或者Visual C++创建项目并且在启动的时候遇到环境问题，那么这个问题很有可能是由于debugger设置问题。如果你按下play或者Start Debugging菜单项，就会产生异常：配置文件(*.cfg)没有找到，那么工作目录(working directory)很有可能设置不正确。
   	解决这个问题没有直接的方法，而是取决于Visual C++的版本，虽然是这样但是基本的步骤是一样的。在solution explorer中的project项上点击右键转到属性页，在配置属性页应该有Debugging选项，在Debugging选项中应该有Working Directory字段，它应该被设置为你的可执行文件的位置。
   	如果你不知道应该把什么东西放在那儿，试着模仿Command字段（应该也在Debugging选项中）。例如，在Visual C++2003中，Command字段类似于“..\..\bin\$(ConfigurationName)\$(TargetFileName)”。对于工作目录（Working Directory）我们应该命令中与部分文件名有关的。。在本例，工作目录应该是这样的：..\..\bin\$(ConfigurationName)。你实际应该放在这儿的字符串取决于你使用的Visual C++的版本和你的编译环境，所在在这之前请确保对命令字段进行了检查。确保对Release和Debug都修改了工作目录。
   	在Visual C++2005中有些事情可能完全不同。我发现“..\..\bin\$(ConfigurationName)”目录作为第一个尝试是不错的主意，如果没有成功的话,那你可能要和它好好玩玩了或者去帮助论坛求救。
   	如果你使用的是Code::Blocks那么你需要做同样的事情，请右键点击project选择“Properties”，转到"Build Targets",然后改变“Execution working dir”字段，使它表示你的可执行文件目录。
   	这么做的理由是Ogre认为某些文件和可执行文件位于同一个目录，不需要将工作目录设置为这些文件所在的目录，它不会起作用的。
   	一旦你成功的运行了你的程序，那么请继续移除createScene()函数中的代码，但是不要把函数移除了，我们将把代码放在这个函数中并且逐行演示它。
   	-------------------------------------------------------------------------------------------------------------------------
   	
Ogre是如何工作的
—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
	这是一个很宽广的问题，我们将从SceneManagers开始，接着到Entities和SceneNodes，这3个类是构建Ogre程序的基础。
	
	SceneManager 基础
	-------------------------------------------------------------------------------------------------------------------------
		出现在场景中的任何东西都是有SceneManager管理的。当你将一个物体放在场景中，SceneManager是一个记录物体位置的类。当你创建Cameras去观察这个场景（这将在后面的教程中介绍），SceneManager也会记录它们（相机），SceneManager同样会记录你创建的平面、广告牌、光线等物体。
		有多重类型的SceneManager，有渲染地形的SceneManager，有渲染BSP map的SceneManager等等。在这儿(http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ)你可以看到各种类型的SceneManager，随着教程的进度，我们将会介绍更多的SceneManager。
	Entity 基础
	-------------------------------------------------------------------------------------------------------------------------
		实体（Entity）是指你可以在场景中渲染的一个物体，你可以认为实体是由3D网格表示的任何东西。一个机器人是一个实体，一条鱼		是一个实体，你的角色行走在地形上将是一个很大的实体。但是像光、广告牌、粒子相机等不是实体。
		关于Ogre需要注意的是：它将可渲染对象的位置和方向分开了。这意味着你不能直接将实体放在场景中。你应该将实体附加到场景节点（SceneNode）上，场景节点包含了位置和方向信息。
		
	SceneNode 基础
	-------------------------------------------------------------------------------------------------------------------------
   		正如上面提到的，SceneNode记录了所有附加到它上面的物体的位置和方向。只有当你将创建的实体附加到SceneNode上时，实体才会被渲染。此外SceneNode 不是在屏幕上显示的对象，只有当你创建了一个SceneNode并将一个实体附加到它上面时，它才会在屏幕上显示。
   		SceneNode上可以任意数量的对象，也就是说你有一个角色对象沿着屏幕走，你想在角色周围创建一个光源。那么你应该这样做：首先创建一个SceneNode，然后创建一个角色实体并将实体附加到SceneNode上，接着你将创建一个光源对象并将光源附加到SceneNode上。SceneNode同样可以附加到SceneNode上，这意味着你可以SceneNode可以继承SceneNode。在后面的教程中我们将介绍更多的关于SceneNode的高级应用。
   		关于SceneNode一个很重要的概念需要注意：SceneNode的位置通常是相对于父SceneNode的，每个SceneManager都有一个根节点，所有其他的SceneNode都可以附加到它上面。
   	-------------------------------------------------------------------------------------------------------------------------
   	
  你的第一个Ogre程序
  ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  	现在回到我们之前创建的代码。找到TutorialApplication::createScene成员函数，在本教程中，我们只会修改这个函数的内容。为了能看到我们做了什么，我们首先需要做的是给场景添加环境光。我们通过SceneManager::setAmbientLight函数并指定我们想要的颜色来创建环境光。注意：ColourValue的构造函数需要红、绿、蓝三种颜色，颜色值的范围为0-1，在createScene中加入下面这行：
  	mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5f, 0.5f, 0.5f));
  	接下来我们要做的是创建一个实体，我们通过调用SceneManager的createEntity成员函数来创建一个实体。
  	Ogre::Entity* ogreHead = mSceneMgr->createEntity("Head", "ogrehead.mesh");
  	好了，有几个问题出现了：
  		（1）mSceneMgr从哪儿来的？
  		（2）我们调用的函数的参数是什么？
  	    mSceneMgr变量包含了当前的SceneManager对象。就目前而言，这是由BaseApplication完成的。
  	    createEntity接受2个参数：
  		（1）我们创建的实体的名称，名称作为字符串传入（这里名称为"Head"），所有的实体都必须有唯一的名称。如果你创建了两个相同名称的实体那么你会遇到错误。
  		（2）实体用到的网格（这里我们将它指定为“ogrehead.mesh”）。
  		教程资源
  		---------------------------------------------------------------------------------------------------------------------
  		“ogrehead.mesh”是一个来自Ogre SDK的资源。后面的教程将会包含资源加载的过程，但是现在我们使用BaseApplication类来加载资源
  		--------------------------------------------------------------------------------------------------------------------
  		
  		既然我们已经创建了一个实体，我们也需要创建一个SceneNode，将实体附加到它上面。由于SceneManager类有一个根SceneNode，所以我们只需要创建根节点的子节点就可以了。
  		Ogre::SceneNode* headNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("HeadNode");
  		这个很长的声明首先调用当前SceneManager的getRootSceneNode函数得到场景管理器的根节点（场景节点），然后调用根节点的createChildSceneNode函数。createChildSceneNode函数的参数是我们创建的场景节点的名称。像实体类一样，任何两个相同的SceneNode不能有相同的名称。
  		接下来，为了Ogre Head有一个渲染位置，我们将实体附加到场景节点（SceneNode）上：
  		headNode->attachObject(ogreHead);
  		尽管我们知道下个教程才会详细的介绍光源，为了能正确的看到我们的模型的阴影而不是由环境光产生的平面阴影。我们同样给我们创建的光源一个唯一的名称。
  		Ogre::Light* light = mSceneMgr->createLight( "MainLight" );
  		一旦光源（Light）被创建了，那么使用它的成员函数“setPosition”就可以设置它的位置，它的三个参数X、Y、Z是要设置的新的位置的坐标，我们将在下面更加详细的介绍介绍坐标。
  		light->setPosition(20, 80, 50);
  		就这样，编译并运行你的程序，你应该可以在的屏幕上看到一个Ogre头。
  		
  坐标与向量
  ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
    在我们进行深入介绍之前，我们需要讲一下屏幕坐标和Ogre向量（Vector）对象。Ogre（其他的很多图像引擎也是类似）使用X、Z轴作为水平面，Y轴作为垂直轴。当你现在看着你的显示器的时候，X轴从显示器的左边到右边，右边是X的正方向。Y轴从你的显示器的底部到顶部，顶部为正方向。Z轴从显示器的里面指向外面，指向外面的为正方向。
    注意Ogre Head是如何沿着Z轴朝向我们的？这很有可能是网格（mesh）和相机（camera）的位置和朝向属性。我们将在后面的教程中介绍相机（camera），但是现在我们需要认识到Ogre Head位于（0,0,0）处，并且我们从前面看它。头部的朝向是由美工创建和保存网格时的朝向决定的。Ogre关于你的模型朝向不做假设。你加载的每个网格模型可能有不同的初始化朝向。
    
    
    
